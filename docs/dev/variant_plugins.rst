Writing variant plugins
=======================
A few example variant generators are found under ``plugins/variants``. Plugins are registered using the
``mitty.plugins.variants`` entry point. Examples of this can be seen in the ``setup.py`` script for the supplied
variant generators. We will inspect relevant parts of the supplied ``snp`` plugin to see how we can write plugins.

The plugin module needs to expose one generator function accepting at least two parameters::

  variant_generator(ref={}, master_seed=1, ...)


``ref`` is the reference chromosome as a :py:class:`mitty.lib.genome.FastaGenome` object. ``master_seed`` is an integer
``0 < master_seed < mitty.lib.SEED_MAX``. The seed is generated by the calling program (such as ``denovo``) and is
meant to be used by any random number generators run by the model. The seed is generated from the master_seed passed
via the input parameter file.

The function should return a generator. Each run of the iterator should return a dictionary whose keys are the
chromosome number the variants are for and the value should be the list of proposed variants
(:py:class:`mitty.lib.variation.Variation`), like so::


  for chrom in chromosome:
    ref_chrom = ref[chrom]
    snp_locs = util.place_poisson(base_loc_rng, p, len(ref_chrom))
    het_type = util.het(snp_locs.size, phet, het_rng, copy_rng)
    base_subs = base_sub_rng.randint(3, size=snp_locs.size)

    yield {chrom: [new_variation(pos + 1, pos + 2, ref_chrom[pos], base_sub_dict[ref_chrom[pos]][bs], het)
                   for pos, bs, het in zip(snp_locs, base_subs, het_type) if ref_chrom[pos] != 'N']}
    # +1 because VCF files are 1 indexed
    #alts will be 0 if ref is not one of ACTG

In this case we loop over each chromosome, sending out a list of variants each time we loop. It is perfectly legal to
return variants on multiple chromosomes as well.

In addition to the generator function the module should also expose:

An example parameter string. This is used for the help as well as for the integration test the test suite can run
automatically on all discovered plugins::

    __example_param_text = """
    {
      "chromosome": [4],      # List of chromosomes to apply the variant to
      "p": 0.01,              # probability that the SNP will happen at any given base
      "phet": 0.5,            # probability that the variant will be heterozygous
    }
    """

A description text that is printed when the model is described::

    _description = """
    This is the stock SNP plugin. A typical parameter set resembles
    """ + __example_param_text

A dictionary that is passed to the integration test as an example parameter set. I usually use the same string as for
the description so I don't have to repeat myself::

    _example_params = eval(__example_param_text)

Typically, you will be distributing your plugin as a separate Python package. You need to register the package as a
Mitty plugin by indicating an entry point in your ``setup.py`` script.

Assuming that your module is named ``snp_plugin.py`` and the directory structure of your code is

    mitty_snp
         |--> snp_plugin.py
    setup.py

Your ``setup.py`` script would indicate the entry point as::

    entry_points = {'mitty.plugins.variants': ['mysnp = mitty_snp.snp_plugin']}

Users would call this model by the name ``mysnp`` in their parameter files. Python currently allows you to add duplicate
entry point names. Be aware that, though this plugin will be listed, the plugin that was installed first will be the
one that is used

A complete ``setup.py`` would look like::

    from setuptools import setup, find_packages

    setup(
        name='mitty_plugin_snp',
        version='1.0.0',
        description='An example set of plugins for Mitty',
        author='Seven Bridges Genomics',
        author_email='kaushik.ghose@sbgenomics.com',
        packages=find_packages(include=['mitty_snp']),
        entry_points = {'mitty.plugins.variants': ['mysnp = mitty_snp.snp_plugin']}
    )

